<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DSA Course</title>
  <style>
    /* General Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Body Styling */
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
      color: #f0f0f0;
      padding: 20px;
      line-height: 1.6;
    }

    /* Container Styling */
    .course-container {
      max-width: 900px;
      margin: 0 auto;
      background-color: rgba(20, 34, 43, 0.95);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6);
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
      color: #00cec9;
    }

    .topic {
      margin-bottom: 20px;
      padding: 20px;
      background-color: #1b2a35;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }

    .topic h3 {
      color: #00cec9;
      margin-bottom: 10px;
    }

    .topic p,
    .topic ul {
      margin: 0;
      color: #dfe6e9;
    }

    .topic ul {
      margin-left: 20px;
      list-style-type: disc;
    }

    pre {
      background-color: #2e4053;
      color: #dcdde1;
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      margin-top: 10px;
      font-size: 14px;
    }

    .back-button {
      display: block;
      margin: 30px auto 0;
      padding: 15px 30px;
      font-size: 16px;
      background-color: #00cec9;
      color: black;
      text-align: center;
      text-decoration: none;
      border-radius: 8px;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: bold;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    .back-button:hover {
      background-color: #01b2a3;
    }
  </style>
</head>
<body>
  <div class="course-container">
    <h1>Data Structures and Algorithms (DSA) Course</h1>

    <!-- Introduction Section -->
    <div class="topic">
      <h3>1. What is DSA?</h3>
      <p>Data Structures and Algorithms (DSA) is the foundation of computer science, focusing on organizing data and solving problems efficiently.</p>
      <p>Key topics covered in DSA:</p>
      <ul>
        <li>Understanding and implementing data structures like arrays, linked lists, and trees.</li>
        <li>Designing algorithms for problem-solving (e.g., searching, sorting).</li>
        <li>Analyzing algorithm efficiency using time and space complexity.</li>
      </ul>
    </div>

    <!-- Arrays Section -->
    <div class="topic">
      <h3>2. Arrays</h3>
      <p>Arrays are a collection of elements stored in contiguous memory locations.</p>
      <ul>
        <li><b>Advantages:</b> Random access to elements.</li>
        <li><b>Disadvantages:</b> Fixed size and costly insertion/deletion operations.</li>
      </ul>
      <p>Common operations:</p>
      <pre><code>
// Insert an element
arr[index] = value;

// Traverse the array
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}

// Search for an element
int search(int[] arr, int key) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == key) return i;
    }
    return -1;
}
      </code></pre>
    </div>

    <!-- Linked Lists Section -->
    <div class="topic">
      <h3>3. Linked Lists</h3>
      <p>A Linked List is a dynamic data structure where elements (nodes) are linked using pointers.</p>
      <ul>
        <li><b>Types:</b> Singly Linked List, Doubly Linked List, Circular Linked List.</li>
        <li><b>Advantages:</b> Dynamic size, efficient insertion and deletion.</li>
        <li><b>Disadvantages:</b> Sequential access (no random access).</li>
      </ul>
      <pre><code>
// Node structure for a singly linked list
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

// Traverse a linked list
void traverse(Node head) {
    while (head != null) {
        System.out.println(head.data);
        head = head.next;
    }
}
      </code></pre>
    </div>

    <!-- Stacks Section -->
    <div class="topic">
      <h3>4. Stacks</h3>
      <p>A Stack is a linear data structure following the <b>LIFO (Last In First Out)</b> principle.</p>
      <ul>
        <li><b>Common operations:</b> Push, Pop, Peek.</li>
        <li><b>Applications:</b> Undo functionality, balanced parentheses, recursion.</li>
      </ul>
      <pre><code>
// Push operation
stack.push(value);

// Pop operation
int value = stack.pop();

// Peek operation
int top = stack.peek();
      </code></pre>
    </div>

    <!-- Queues Section -->
    <div class="topic">
      <h3>5. Queues</h3>
      <p>A Queue is a linear data structure following the <b>FIFO (First In First Out)</b> principle.</p>
      <ul>
        <li><b>Types:</b> Simple Queue, Circular Queue, Priority Queue, Deque.</li>
        <li><b>Applications:</b> Task scheduling, BFS traversal.</li>
      </ul>
      <pre><code>
// Enqueue operation
queue.enqueue(value);

// Dequeue operation
int value = queue.dequeue();
      </code></pre>
    </div>

    <!-- Trees Section -->
    <div class="topic">
      <h3>6. Trees</h3>
      <p>Trees are hierarchical data structures composed of nodes.</p>
      <ul>
        <li><b>Binary Tree:</b> Each node has at most two children (left and right).</li>
        <li><b>Binary Search Tree:</b> A binary tree with sorted nodes for fast lookup.</li>
        <li><b>Applications:</b> File systems, decision-making, expression evaluation.</li>
      </ul>
      <pre><code>
// In-order traversal
void inOrderTraversal(Node root) {
    if (root == null) return;
    inOrderTraversal(root.left);
    System.out.println(root.data);
    inOrderTraversal(root.right);
}
      </code></pre>
    </div>

    <!-- Graphs Section -->
    <div class="topic">
      <h3>7. Graphs</h3>
      <p>A Graph is a non-linear data structure consisting of nodes (vertices) connected by edges.</p>
      <ul>
        <li><b>Types:</b> Directed, Undirected, Weighted, Unweighted.</li>
        <li><b>Applications:</b> Social networks, route optimization, web crawling.</li>
      </ul>
      <pre><code>
// BFS Traversal
void bfs(Graph graph, int startNode) {
    Queue queue = new LinkedList();
    Set visited = new HashSet();
    queue.add(startNode);

    while (!queue.isEmpty()) {
        int current = queue.poll();
        System.out.println(current);
        for (int neighbor : graph.getNeighbors(current)) {
            if (!visited.contains(neighbor)) {
                visited.add(neighbor);
                queue.add(neighbor);
            }
        }
    }
}
      </code></pre>
    </div>

    <!-- Algorithms Section -->
    <div class="topic">
      <h3>8. Sorting and Searching Algorithms</h3>
      <p>Efficient algorithms for organizing and retrieving data.</p>
      <ul>
        <li><b>Sorting:</b> Bubble Sort, Merge Sort, Quick Sort, Heap Sort.</li>
        <li><b>Searching:</b> Linear Search, Binary Search.</li>
      </ul>
      <pre><code>
// Binary Search
int binarySearch(int[] arr, int key) {
    int low = 0, high = arr.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == key) {
            return mid;  // Key found at index mid
        } else if (arr[mid] < key) {
            low = mid + 1;  // Key is in the right half
        } else {
            high = mid - 1;  // Key is in the left half
        }
    }
    return -1;  // Key not found
}
      </code></pre>
    </div>

    <!-- Complexity Analysis Section -->
    <div class="topic">
      <h3>9. Time and Space Complexity</h3>
      <p>Time and space complexity are used to evaluate the efficiency of algorithms. Common notations:</p>
      <ul>
        <li><b>Big O (O):</b> Represents the upper bound, i.e., the worst-case scenario.</li>
        <li><b>Big Omega (Ω):</b> Represents the lower bound, i.e., the best-case scenario.</li>
        <li><b>Big Theta (Θ):</b> Represents the exact bound for an algorithm (both upper and lower bounds).</li>
      </ul>
      <p>For example:</p>
      <ul>
        <li><b>Bubble Sort:</b> O(n²) time complexity in the worst case.</li>
        <li><b>Binary Search:</b> O(log n) time complexity in a sorted array.</li>
      </ul>
      <pre><code>
// Time complexity of an algorithm (e.g., for a loop)
for (int i = 0; i < n; i++) {
    // O(n) operation inside the loop
}
      </code></pre>
    </div>

    <!-- Recursion Section -->
    <div class="topic">
      <h3>10. Recursion</h3>
      <p>Recursion is a method where the solution to a problem depends on solutions to smaller instances of the same problem.</p>
      <p>Example: Calculating the factorial of a number using recursion.</p>
      <pre><code>
// Factorial using recursion
int factorial(int n) {
    if (n == 0 || n == 1) return 1;
    return n * factorial(n - 1);
}
      </code></pre>
      <p><b>Important:</b> Recursion often involves a base case to stop the function from calling itself indefinitely.</p>
    </div>

    <!-- Dynamic Programming Section -->
    <div class="topic">
      <h3>11. Dynamic Programming (DP)</h3>
      <p>Dynamic Programming is a technique for solving problems by breaking them down into simpler subproblems and solving each subproblem only once.</p>
      <ul>
        <li><b>Memoization:</b> Top-down approach where results of subproblems are stored in a cache.</li>
        <li><b>Tabulation:</b> Bottom-up approach where a table is built iteratively.</li>
      </ul>
      <p>Example: Fibonacci series using DP.</p>
      <pre><code>
// Fibonacci using DP (Tabulation)
int fib(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
      </code></pre>
    </div>

    <!-- Back Button -->
    <a href="updatedcourse.html" class="back-button">Back to Home</a>
  </div>
</body>
</html>
